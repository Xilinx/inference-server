<ac:structured-macro ac:name="anchor">
<ac:parameter ac:name="">architecture-overview</ac:parameter>
</ac:structured-macro>
<ac:structured-macro ac:name="info">
<ac:parameter ac:name="icon">false</ac:parameter>
<ac:rich-text-body>
<ac:image ac:align="left" ac:alt="Diagram showing Xilinx Inference Server&apos;s architecture" ac:height="400">
<ri:attachment ri:filename="architecture.png"></ri:attachment>
</ac:image><p style="clear: both;">Fig. 1 Server architecture overview</p>
<div></div>
</ac:rich-text-body>
</ac:structured-macro>
<h2>Overview</h2>
<p><ac:link ac:anchor="architecture-overview">
<ac:link-body>Fig. 1</ac:link-body>
</ac:link> shows a high-level view of the Server’s architecture. At the top, we have a client who can make a request to the Server using HTTP/REST, WebSocket, or the C++ API <ac:structured-macro ac:name="anchor">
<ac:parameter ac:name="">id1</ac:parameter>
</ac:structured-macro>
<sup><ac:link ac:anchor="f1">
<ac:plain-text-link-body><![CDATA[[1]]]></ac:plain-text-link-body>
</ac:link></sup>. This request must be made to a particular worker that must be active in the Server. Each received request is passed to a batcher associated with the targeted worker independent of its origin. The batcher will combine individual requests into a batch and pass it to the worker for execution. The worker parses the batch, processes each request contained within, and responds to the client. Internally, the worker can leverage any C++ logic and/or use external libraries such as Vitis AI or machine learning frameworks to process the request. This flexibility enables the Server to take advantage of any hardware accelerator with the appropriate worker. The response to the client is made using the same API as the original request.</p>
<h2>Ingestion</h2>
<p>There are a number of ways to get data into the system for inference. In general, each protocol has a custom interface to the client and requires explicit handling in the Server to accept this initial request. After receiving the client’s request in the Server, each supported protocols’ handler packs the request into an implementation of an <code>Interface</code> object. This virtual class is defined in the Server and provides the batcher with a standard way of interacting with data from different ingestion protocols. Since all protocols push an implementation of this class to the batcher, they are treated equally by the rest of the Server. The only protocol-specific logic applies at the end of the worker when it replies back to the client in a protocol-specific manner. This structure also enables easy extension of the Server to add new protocols by extending the <code>Interface</code> class.</p>
<h3>API</h3>
<p>The APIs used for this project are based on <a href="https://github.com/kserve/kserve/blob/master/docs/predict-api/v2/required_api.md">KServe’s v2 specification</a> where possible. The API defines endpoints in different categories: health, metrics and prediction. The health APIs define endpoints to get Server metadata and check server readiness. The metrics API defines a single endpoint for exposing the collected metrics using the Prometheus format. The prediction APIs are used to make inferences.</p>
<p>For inference, we provide <code>load</code> and <code>unload</code> endpoints for clients to control which workers are active (and how many instances of each). The load API accepts an optional set of parameters that define <strong>load-time parameters</strong>. On success, the load API returns a string corresponding to the endpoint that clients should use to make prediction requests from the loaded worker. Note, this usage differs slightly from KServe’s specifications. With KServe, the load API returns only the status code and the requests are made to the same endpoint as the string specified in the load request. It also doesn’t have the notion of load-time parameters. In our case, there are parameters we need to pass at load-time, which results in potentially different endpoints if multiple workers with different configurations are loaded at once. To maintain compatibility, we do guarantee that the first worker loaded for a particular model, independent of configuration, will be at the same endpoint as the load request. Therefore, a KServe client is free to ignore the contents of the response and make requests to the endpoint without resulting in errors.</p>
<p>We currently do not support the optional version information associated with a model defined in the KServe specification. After a particular worker is loaded, inference requests can be made to it by constructing the appropriate request object and sending it to the prediction endpoint. The format of the request object in HTTP matches KServe’s specification while an equivalent C++ object is used for the C++ API.</p>
<h3>HTTP/REST and WebSocket</h3>
<p>The HTTP/REST and WebSocket functionality in the Server is provided using <a href="https://github.com/drogonframework/drogon">Drogon</a>. We chose to use Drogon for our web framework for a few reasons:</p>
<ul>
<li>
<p>Based on the benchmarks at <a href="https://github.com/TechEmpower/FrameworkBenchmarks/">TechEmpower</a>, Drogon is high-performing (unlike CppCMS and Treefrog)</p>
</li>
<li>
<p>It is more stable and active than Lithium, another high-performing framework (Lithium is newer)</p>
</li>
<li>
<p>Active on Github with versioned releases (unlike Pistache and Lithium)</p>
</li>
</ul>
<p>The various endpoints from the API are registered in the Drogon’s HTTP controller along with their request handler functions. Drogon uses a configurable number of threads to run these request handlers. When a REST request is made to an endpoint, the request data and callback function are provided for the handler to process the request and then respond to the client. To avoid blocking the finite number of handler threads with potentially long-running inference requests, we use an asynchronous architecture in the handler. The received request is packed into an <code>Interface</code> object and pushed into a <a href="https://github.com/cameron314/concurrentqueue">thread-safe lock-free multi producer/consumer queue</a> to go to the target worker’s batcher. The HTTP server code is in <code>src/proteus/servers/http_server.*</code>.</p>
<p>Drogon also provides a WebSocket server, which is currently used experimentally to run predictions on videos from certain workers. The WebSocket API is custom. At this time, the client provides a URL to a video that the worker will retrieve and analyze frame-by-frame and send back to the client but this is subject to change. The WebSocket server code is in <code>src/proteus/servers/websocket_server.*</code>.</p>
<h3>C++ API</h3>
<p>The C++ API allows users to compile custom applications that link directly to the Server’s backend. As a result, using the C++ API will yield the highest performance of any ingestion method.</p>
<p>The C++ API provides functions similar to the prediction API used in HTTP. The API lets users load workers and make inference requests. The inference request is packed into an <code>Interface</code> object and pushed to the target worker’s batcher. An <code>std::promise</code> is returned to the user to retrieve the result.</p>
<p>The public API is defined in <code>include/proteus/clients/native.hpp</code> and the implementation is in <code>src/proteus/clients/native.cpp</code>.</p>
<h2>Batching</h2>
<ac:structured-macro ac:name="anchor">
<ac:parameter ac:name="">architecture-detail</ac:parameter>
</ac:structured-macro>
<ac:structured-macro ac:name="info">
<ac:parameter ac:name="icon">false</ac:parameter>
<ac:rich-text-body>
<ac:image ac:align="left" ac:alt="Diagram showing more detail in to the Xilinx Inference Server&apos;s architecture" ac:height="400">
<ri:attachment ri:filename="architecture_detailed.png"></ri:attachment>
</ac:image><p style="clear: both;">Fig. 2 More detailed look at the Server architecture</p>
<div></div>
</ac:rich-text-body>
</ac:structured-macro>
<p>Batching is a technique used in hardware to improve throughput performance. Batching groups multiple smaller requests from the user into one large request to improve the performance of hardware accelerators. However, user requests at the software application level are usually not conveniently available as complete batches as they come one at a time. The Server incorporates batching as a transparent step in the pipeline that groups all incoming requests, independent of the source of the original request from the client (see <code>architecture_detailed</code>). The implementations of the batchers are in <code>src/proteus/batching</code>.</p>
<p>The base batcher class defines a common interface for all batcher implementations and has some basic common properties. Each batcher has two thread-safe queues (one for input and one for output), a configured batch size and a string identifying the worker group it’s attached to. The batcher runs as a separate thread that monitors its input queue to process incoming <code>Interface</code> objects from all ingestion methods and pushes completed <code>Batch</code> objects on the output queue. Each batcher implementation defines a <code>run()</code> method that provides the logic with which the batcher produces a batch. A worker (and by extension, the worker group) specifies which batcher implementation should be used to prepare batches for it (as well as the batch size) and each worker group shares a set of batchers. This configuration is determined at compile-time and built into the definition of the worker.</p>
<p>A <code>Batch</code> is made up of three basic components: <code>InferenceRequest</code> objects and input/output buffers. <code>InferenceRequest</code> objects are direct C++ implementations of the information present in the KServe API of an inference request structured in a similar format. They provide an ingestion-agnostic data format that all workers can process. The worker group that the batcher is attached to provides a set of input/output buffers from a pool of buffers that it allocates. These buffers are available in a queue for that batcher to pull from when it has incoming requests to batch together. Most commonly, each buffer can be used to represent one batch-size worth of contiguous memory but its exact nature depends on the buffer implementation that the worker is using. In this case, the batcher’s job is to take individual requests and move its data into one slot of this buffer and construct the corresponding <code>InferenceRequest</code> object. Batchers have some flexibility with how these batches are constructed, which is why multiple batcher implementations are possible and supported in the Xilinx Inference Server. For example, one batcher may allow partial batches to be pushed on after enough time whereas this may not be allowed by another batcher.</p>
<p>Batchers use the <code>Interface</code> object’s <code>getRequest()</code> method to help create batches. This method must be implemented by each interface and governs how, given some buffers and counters, the particular ingestion method’s data should be converted to an <code>InferenceRequest</code> and its data is copied over to the buffers. THis method allows batchers to process all ingestion methods without knowing about the details of how the data may be stored internally in the <code>Interface</code>.</p>
<h2>Workers</h2>
<p>Workers perform the computation. They are the smallest unit that the Server manages. A worker may be as simple or complex as you like: as long as it adheres to the interface. Each worker is compiled as a shared object that the Server can dynamically open at load-time. Thus, new workers can be loaded and unloaded without stopping the server.</p>
<p>Workers are defined in <code>src/proteus/workers</code>. The <code>CMakeLists.txt</code> file builds each worker as <code>libworkerX.so</code> where <em>X</em> corresponds to the name of the C++ file defining the worker in PascalCase.</p>
<h3>Organization and Lifecycle</h3>
<p>The base Worker class provides the template of all workers for the Server. This class defines the lifecycle methods of the worker that are called by the Server. This lifecycle is defined as follows:</p>
<ol style="list-style-type: decimal;">
<li>
<p><code>init()</code>: perform low-cost initialization of the worker</p>
</li>
<li>
<p><code>allocate()</code>: allocate memory buffers that are used to hold input and output data for the worker. Buffering is further discussed Buffering.</p>
</li>
<li>
<p><code>acquire()</code>: acquire any hardware accelerators/resources and/or perform any high-cost initialization for the worker</p>
</li>
<li>
<p><code>run()</code>: the main body of the worker performs the chosen computations on incoming batches</p>
</li>
<li>
<p><code>release()</code>: release any hardware accelerators/resources</p>
</li>
<li>
<p><code>deallocate()</code>: free the memory buffers allocated by this worker</p>
</li>
<li>
<p><code>destroy()</code>: perform any final operations prior to shutdown</p>
</li>
</ol>
<p>The first three steps set up the worker while the latter three tear it down and are performed in this order by the Server. The body of these methods must be provided by each worker implementation in the corresponding <code>doX()</code> methods (e.g. <code>doInit()</code>). At load-time, the server will create an instance of the worker using its <code>getWorker()</code> method:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">cpp</ac:parameter>
<ac:parameter ac:name="linenumbers">false</ac:parameter>
<ac:plain-text-body><![CDATA[extern "C" {
    proteus::workers::Worker* getWorker() { return new proteus::workers::MyWorkerClass(); }
}]]></ac:plain-text-body>
</ac:structured-macro>
<p>This instance is saved internally and the first three methods above are called to initialize the worker. The worker’s batcher is also started by the server at this time. Finally, the worker’s <code>run()</code> method is started as a separate thread with the batcher’s output queue passed as the input queue to the worker. This method performs the body of the work. In an infinite loop, this method should wait for incoming batches from the worker’s input queue, process the requests, and respond to the clients.</p>
<p>To unload a worker, the Manager sends a <code>nullptr</code> to the worker, which should terminate the <code>run()</code> thread. This thread is joined and the last three lifecycle methods are called to safely clean up the worker.</p>
<h3>Improving Performance</h3>
<p>Having multiple workers of the same kind can improve performance if there are many incoming batches. Multiple identical workers are grouped into one worker group (see <ac:link ac:anchor="architecture-detail">
<ac:link-body>Fig. 2</ac:link-body>
</ac:link>). Each worker group shares one batcher group i.e. each batcher in a batcher group pushes its batches to a common queue that each worker in a worker group is dequeuing from. This structure enables any worker in the group to pull a new batch when it can process it. Therefore, each worker should only pull from this common queue when it can actually process the data. To load a new worker into an existing group, the worker should be loaded with the load-time parameter <code>share</code> set to <em>false</em>.</p>
<h3>External Processing</h3>
<p>Workers, by virtue of their generic structure, may be highly complex and call entirely external applications for processing data. The Xilinx Inference Server supports this use case and suggests the following for organizing code:</p>
<ul>
<li>
<p>The external application can be brought in similarly to how existing external applications are brought in already with CMake</p>
</li>
<li>
<p>The general worker structure should follow the existing model for native workers as defined above</p>
</li>
<li>
<p>After determining that a request is valid, the worker should convert the native request into something that the external application understands</p>
</li>
<li>
<p>Then, the data can be passed over to the external application.</p>
</li>
<li>
<p>The external application should return its results back to the worker</p>
</li>
<li>
<p>The response needs to be converted back to the native format to reply to the client</p>
</li>
</ul>
<p>Currently, there are no rules that the Server enforces for what workers are allowed to do and if they must expose any other functionality to the Server though this will change in the future. For example, the Server will eventually need to send health check requests to workers that must be responded to appropriately.</p>
<h3>XModel</h3>
<ac:structured-macro ac:name="anchor">
<ac:parameter ac:name="">fig-xmodel</ac:parameter>
</ac:structured-macro>
<ac:structured-macro ac:name="info">
<ac:parameter ac:name="icon">false</ac:parameter>
<ac:rich-text-body>
<ac:image ac:align="left" ac:alt="Diagram showing the structure of the XModel worker" ac:height="300">
<ri:attachment ri:filename="xmodel.png"></ri:attachment>
</ac:image><p style="clear: both;">Fig. 3 The XModel worker</p>
<div></div>
</ac:rich-text-body>
</ac:structured-macro>
<p>As perhaps the most complex worker thus far, the architecture of the XModel worker is examined here in greater detail. The XModel worker is intended to run an arbitrary XModel specified by the user on a Xilinx FPGA <ac:structured-macro ac:name="anchor">
<ac:parameter ac:name="">id2</ac:parameter>
</ac:structured-macro>
<sup><ac:link ac:anchor="f3">
<ac:plain-text-link-body><![CDATA[[3]]]></ac:plain-text-link-body>
</ac:link></sup>. We take a look at the lifecycle of this worker in the following sections.</p>
<h4>Initialization</h4>
<p>The XModel worker needs a path to an XModel to run at load-time. This XModel file is opened and parsed to get the graph and the first DPU subgraph (i.e. the first subgraph in the graph that is supposed to run on the FPGA). In the future, we may support running an arbitrary number of subgraphs but this simple case is often sufficient. Using this subgraph, we create a <em>Runner</em>, which is a thread-safe object defined in the Vitis-AI runtime and is responsible for submitting requests to the FPGA. These objects are all saved as part of the internal state of the worker.</p>
<h4>Allocation</h4>
<p>We use a special buffer backend for the this worker: the VartTensorBuffer. This custom type provides better compatibility with using the Runner as that expects <code>vart::TensorBuffer</code> objects to pass data to the FPGA. Therefore, this worker creates buffers using this backend and passes them to the Manager.</p>
<h4>Acquisition</h4>
<p>Since the Runner is thread-safe, we can use multiple threads to push data to the FPGA from the same Runner to improve throughput. To enable this functionality, we incorporate an internal thread pool in the XModel worker. Here, we set the size of this thread pool based on user parameters.</p>
<h4>Run</h4>
<p>As with all workers, the XModel worker pulls batches from its inputs queue and checks if it’s a <code>nullptr</code> before continuing to process the batch. If valid, the batch is pushed into the thread pool, which internally assigns a lambda function to one of its internal threads to perform the processing. This lambda function performs the same work that other workers normally perform directly in the <code>run()</code> method itself. Here, for each batch, we push the data to the FPGA with the Runner and start preparing the response while waiting for the asynchronous operation to return. Then, the response from the FPGA is parsed, the client response is populated with this data and the callback is called to respond back to the client.</p>
<p>To prevent the worker from pulling too many batches, an atomic counter is used to track the number of outstanding batches in the worker. If the number is above a configured amount, then the worker doesn’t pull more batches until it has processed some of the ones it already has. This throttling is necessary for the work-stealing model for workers to work.</p>
<h4>Cleanup</h4>
<p>There is almost no special cleanup required as the Vitis-AI objects that are part of the worker’s state are smart pointers and are cleaned by the worker’s destructor. THe only non-default implementation of the clean-up functions is to stop the internal thread pool and join the threads.</p>
<h2>Buffering</h2>
<ac:structured-macro ac:name="anchor">
<ac:parameter ac:name="">fig-buffering</ac:parameter>
</ac:structured-macro>
<ac:structured-macro ac:name="info">
<ac:parameter ac:name="icon">false</ac:parameter>
<ac:rich-text-body>
<ac:image ac:align="left" ac:alt="Diagram showing the buffer lifecycle" ac:height="400">
<ri:attachment ri:filename="buffer_lifecycle.png"></ri:attachment>
</ac:image><p style="clear: both;">Fig. 4 The buffer lifecycle</p>
</ac:rich-text-body>
</ac:structured-macro>
<p>Buffers are used to hold data internally within the server after receiving a request. The implementations of buffers are in <code>src/proteus/buffers</code>.</p>
<p>The lifecycle of buffers is shown in <ac:link ac:anchor="fig-buffering">
<ac:link-body>Fig. 4</ac:link-body>
</ac:link>. In <code>allocate()</code>, the worker creates a buffer pool made of some number of buffers. Using a buffer pool saves the cost of constantly allocating dynamic memory for each new request. Instead, we can reuse the same set of buffers that are allocated by the worker at one time. They are initially provided by the worker to the Manager which maintains a queue of buffers for storing the coalesced requests for one batch. The buffers of all the workers in one group are maintained in this common queue. They are consumed from the pool as the batcher creates batches and then the worker returns them to the pool after finishing work on a batch. If the batcher needs a buffer but there are none available, the batcher can block execution until a buffer becomes available. Thus, the number of buffers in the pool controls the number of active batches for a particular worker group. Currently, there’s no mechanism to change the number of buffers in the pool at run-time short of allocating a new worker or sending a large request that forces the automatic allocation of more buffers. In the future, the number of buffers may be controllable from the Manager and dynamically managed depending on the number of requests.</p>
<p>Multiple kinds of buffer backends are supported by providing the appropriate wrappers. For example, a simple implementation may use buffers allocated in CPU memory. For more advanced sharing of data and to minimize data movement, buffers may be allocated in shared memory or on hardware accelerators. Buffer backends extend the <code>Buffer</code> class. They provide methods to write different data types into the buffer and access the underlying data at some offset.</p>
<h2>Manager</h2>
<p>The shared state of Proteus is maintained by the Manager: the active workers, their buffer pools, the endpoints and load-time parameters associated with them and is visualized+ in <ac:link ac:anchor="architecture-detail">
<ac:link-body>Fig. 2</ac:link-body>
</ac:link>. This information enables the ingestion protocols to query the Manager to retrieve a pointer to the correct batcher to use to push the <code>Interface</code> object to the right one corresponding to the targeted worker. To manage multiple versions of workers that may be running with different configurations, the Manager stores the load-time parameters, if any, and compares new parameters with ones its seen before to determine whether the newly loaded worker should be part of an existing worker group or a new one. In the case that it’s assigned to an existing worker group, the previously allocated endpoint is returned to the client. If a new worker group is created, a new endpoint is reserved for this worker group and returned to the client. The implementation is in <code>src/proteus/core/manager.*</code>.</p>
<p>Loading a new worker results in the creation of a new <code>WorkerInfo</code> (see <code>src/proteus/core/worker_info.*</code>) object which the Manager uses internally to hold all the information associated with the worker. The worker class instance, its batcher, and its buffer pool are all stored in this object. The <code>WorkerInfo</code> object provides two methods to create new workers: its constructor and an <code>addAndStartWorker()</code> method. The former is used for a brand-new worker and creates queues for the buffer pools and initializes the private members of the class. The latter loads the shared library associated with the worker, creates and saves the instance of the worker class, and starts its <code>run()</code> method in a new thread.</p>
<p>The Manager also provides methods to safely modify the shared state such as loading or unloading new workers. Such actions must be taken with care because there are many threads that may need to modify state or make decisions based on the current state. The Manager uses a queue and a separate thread for this purpose. All methods that modify state enqueue requests to this queue. These methods may be called from a multi-threaded context and so multiple duplicate or contradictory requests are possible. The queue enforces serialization and defines an ordering for all incoming requests so they can be processed in this order by the new thread. Here, duplicate or contradictory requests can be silently dropped so the shared state isn’t corrupted.</p>
<h2>Observation</h2>
<p>Visibility into the server and its operations is provided through logging, metrics and tracing. The implementations of these components is in <code>src/proteus/observation</code>.</p>
<h3>Logging</h3>
<p>The Server uses <a href="https://github.com/gabime/spdlog">spdlog</a> to provide logging. By default, one logger is configured with <code>initLogging()</code>, which logs data to a file on the disk and prints warning messages to the terminal as well. The preprocesser directive form of logging is used throughout the Server, which enables all logging data to be optionally removed at compile-time.</p>
<p>Look at <ac:link ac:anchor="Logs">
<ri:page ri:content-title="Logs" />
<ac:link-body>Logs</ac:link-body>
</ac:link> for more information.</p>
<h3>Metrics</h3>
<p>The Server uses <a href="https://github.com/jupp0r/prometheus-cpp">prometheus-cpp</a> to provide metric collection in the Prometheus format. The metric data can be queried via the web server at the <code>/metrics</code> endpoint. At compile-time, the metrics of interest must be defined in the <code>Metrics</code> class. It provides methods for functions in other classes to modify the metric state. Metric collection can be disabled at compile-time with a CMake option.</p>
<p>Look at <ac:link ac:anchor="Metrics">
<ri:page ri:content-title="Metrics" />
<ac:link-body>Metrics</ac:link-body>
</ac:link> for more information.</p>
<h3>Tracing</h3>
<p>The Server uses <a href="https://github.com/jaegertracing/jaeger-client-cpp">jaeger-client-cpp</a> <ac:structured-macro ac:name="anchor">
<ac:parameter ac:name="">id3</ac:parameter>
</ac:structured-macro>
<sup><ac:link ac:anchor="f2">
<ac:plain-text-link-body><![CDATA[[2]]]></ac:plain-text-link-body>
</ac:link></sup> to provide tracing. Tracing tracks the time taken for different sections of the architecture to process a single request. This data can be visualized in the Jaeger UI. Tracing data can be disabled at compile-time with a CMake option.</p>
<p>Look at <ac:link ac:anchor="Tracing">
<ri:page ri:content-title="Tracing" />
<ac:link-body>Tracing</ac:link-body>
</ac:link> for more information.</p>
<table>
<tbody style="border: none">
<tr>
<td style="border: none"><ac:structured-macro ac:name="anchor">
<ac:parameter ac:name="">f1</ac:parameter>
</ac:structured-macro>
<ac:link ac:anchor="id1">
<ac:plain-text-link-body><![CDATA[[1]]]></ac:plain-text-link-body>
</ac:link></td>
<td style="border: none"><p>Some methods are only available through HTTP at this time. Using the C++ API requires compiling an application linked against <code>libproteus.so</code> rather than making requests to a server.</p>
</td>
</tr>
<tr>
<td style="border: none"><ac:structured-macro ac:name="anchor">
<ac:parameter ac:name="">f2</ac:parameter>
</ac:structured-macro>
<ac:link ac:anchor="id3">
<ac:plain-text-link-body><![CDATA[[2]]]></ac:plain-text-link-body>
</ac:link></td>
<td style="border: none"><p>This library is deprecating and will be replaced with OpenTelemetry as recommended by Jaeger.</p>
</td>
</tr>
<tr>
<td style="border: none"><ac:structured-macro ac:name="anchor">
<ac:parameter ac:name="">f3</ac:parameter>
</ac:structured-macro>
<ac:link ac:anchor="id2">
<ac:plain-text-link-body><![CDATA[[3]]]></ac:plain-text-link-body>
</ac:link></td>
<td style="border: none"><p>There are currently some restrictions on what may be run such as the number of input/output tensors.</p>
</td>
</tr>
</tbody>
</table>
